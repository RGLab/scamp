% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/scamp.R
\name{scamp}
\alias{scamp}
\title{Selective Clustering Annotated using Modes of Projections}
\usage{
scamp(dataSet, numberIterations = 100, clusterOutputString = c("."),
  pValueThreshold = 0.25, minimumClusterSize = 25,
  maximumSearchDepth = 1e+06, maximumClusterNum = (50 * ncol(dataSet)),
  maximumAntimodeNumber = 100, maximumSearchTime = 1e+06,
  annotationVec = colnames(dataSet), finalAnnQs = c(0.499, 0.5, 0.501),
  numberOfThreads = 1, getVotingHistory = FALSE,
  getDebugInfo = FALSE, randomCandidateSearch = TRUE,
  randomResidualCandidateSearch = TRUE, anyValueRestricted = FALSE,
  resValMatrix = matrix(0, nrow = 2, ncol = 2),
  setAnnotationBoudaries = FALSE,
  annotationBoundaryValues = list(rep(0, ncol(dataSet))),
  gaussianScaleParameter = 4, randomSeed = 0,
  allowRepeatedSplitting = FALSE)
}
\arguments{
\item{dataSet}{The input dataSet to be clustered by scamp.
Must be an R matrix. The dataSet should only contain numerical data.}

\item{numberIterations}{The number of scamp iterations to perform.}

\item{clusterOutputString}{scamp generates a number of intermediate
clusterings of the dataSet. When applied to large data sets,
often it is useful to examine these intermediate clusterings.
The clusterOutputString is a path to where this output will be stored.}

\item{pValueThreshold}{The significance level for the DIP test of Hartigan
and Hartigan (1985). scamp uses this level to choose to partition a projection
in the dataSet with the taut-string of Davies and Kovac (2004). Setting it
to smaller values (such as a conventional 0.05) usually produces faster
exaustive clusterings of the dataSet.}

\item{minimumClusterSize}{The size of the smallest admissible candidate cluster.
The recursive search for candidate clusters will not consider subsets of observations
below this value as admissible candidates -- it terminates along such branches without
recording the subsets encountered. Increasing this parameter usually increases
the speed of a single scamp iteration.}

\item{maximumSearchDepth}{An upper bound on the depth of a search tree for candidate clusters.
The recursive search terminates if it exceeds this depth.}

\item{maximumClusterNum}{An upper bound on the number of candidate clusters scamp will find.
If a scamp iteration is exhaustively searching the space of clustering trees, the search will
terminate if scamp finds a collection of candidate clusters that exceed this bound.

If a scamp iteration performs a randomCandidateSearch (or if any values are restricted in the search
process using the resValMatrix) \emph{\bold{the scamp search will continue until it
finds this number of candidate clusters}}.}

\item{maximumAntimodeNumber}{An upper bound on the number of possible antimodes found by the
taut-string estimate of a projection. If the taut-string produces more than the
maximumAntimodeNumber number of antimodes, the recursive search terminates along that branch.}

\item{maximumSearchTime}{The maximum time in seconds a scamp iteration can search for candidate
clusters. If a single iteration exceeds this value in either the intial search phase or
and residual search phases, that scamp iteration is abandonded and the next iteration is
attempted.

On large dataSets (with either a large number of observations or variables), the
initial addition of noise can produce configurations of the dataSet which take much longer
to cluster than the average scamp iteration. This parameter is useful to prevent such iterations
from extending a single scamp call from running too long.}

\item{annotationVec}{A vector of strings that will be used to annotate the projections (columns) in the dataSet.
For the scamp clustering to be interpetable, meaningful strings must be provided here.}

\item{finalAnnQs}{A vector of three increasing values c(qLow,qMed,qHigh), with  0 < qLow < qMed < qHigh < 1.
When scamp annotates selected clusters, it computes the sample quantiles qLow, qMed, and qHigh of each
coordinate project for each selected cluster.

If scamp has found a single annotation boundary for a coordinate projection in the dataset,
both qLow and qHigh are compared to that boundary. If qLow exceeds the annotation boundary, the cluster is labeled
"Highest" along that coordinate. If qHigh falls below the annotation boundary, the cluster is labeled "Lowest"
along that coordinate. Otherwise, the observations in the selected cluster are split into two sub-clusters:
observations below the annotation boundary comprise one of the new sub-clusters, observation above the other.

If scamp has found multiple annotation boundaries for a coordinate, qMed is compared to them and used to annotate
a selected cluster along that coordinate.}

\item{numberOfThreads}{The addition of noise to the dataSet, the random search for candidate clusters,
and the annotation of selected clusters have been parallelized. For numberOfThreads greater than 2,
numberOfThreads-1 worker threads will add noise to the dataSet, conduct the search for candidate clusters,
and annotate the selected clusters. The value of 0 indicates scamp should detect the maximum number
of threads supported by the hardware and then use that value.}

\item{getVotingHistory}{Boolean flag. If true, the complete voting history for
\emph{every} scamp iteration is written the clusterOutputString directory. Only the most recent
voting history and the one preceding it are stored.}

\item{getDebugInfo}{Boolean flag. If true, scamp reports job progress to the R interpreter/log file.}

\item{randomCandidateSearch}{Boolean flag. If true, the initial search for candidate clusters will
sample from the space of clustering trees. At each node in the clustering tree, scamp will pick
the next clustering branch uniformly at random the set of admissible projections (according to the dip).
Especially in small dataSets, this can cause the scamp search to find the same clustering tree multiple
times.}

\item{randomResidualCandidateSearch}{Boolean flag. If true, the search for candidate clusters of observations
not clustered by the initial search and selection will also randomly sample from the space of clustering
trees. Users can choose the combination of exhaustive search and random search for the two stages of
clustering that best suits their dataSet.}

\item{anyValueRestricted}{Boolean flag. If true, indicates the user has some prior knowledge about bounds of
admissible values. Such values must be identified by coordinate projection in the resValMatrix.

The motivation for this parameter is that some technologies produce dataSets which are: very zero-inflated;
have a minimum limit of detection; have an upper limit of detection. Hence, one might wish to indicate that
all values below some threshold be treated as low \emph{by default}, or above a threshold be treated as high
\emph{by default}. Of critical importance: restricted values \emph{\bold{are not used by the taut-string density estimator
in the search for candidate clusters}}.}

\item{resValMatrix}{R matrix indicating restricted values. Contains only three entries: {0,1,2}. If entry (i,j) is 0, it indicates
that observation i is unrestricted along coordinate j (and so is used by the taut-string in the search for cnadidate clusters).

If entry (i,j) is 1, it indicates observation i is \emph{restricted from below} along coordinate j: this observation will
automatically be treated as "Lowest" along coordinate j, and will not be used by the taut-string in the search for candidate clusters.

If entry (i,j) is 2, it indicates observation i is \emph{restricted from above} along coordinate j: this observation will
automatically be treated as "Highest" along coordinate j, and will not be used by the taut-string in the search for candidate clusters.}

\item{setAnnotationBoudaries}{Boolean flag. If true, indicates the user has supplied a list of numeric vectors which
will serve as the annotation boundaries \emph{for each} column in the data set.}

\item{annotationBoundaryValues}{R list of numeric vectors. Each entry in the list corresponds to the columns in the data set. Each vector
contains at least one value that will serve as the annotation boundary for that column.}

\item{gaussianScaleParameter}{Noise is added in a two-step procedure for SCAMP. First, uniform noise is added to
break ties observed in the columns of the dataSet. After uniform noise is added, Gaussian noise is added to perturb
the relative order of the observations in each column of the dataSet. The standard-devaition of the Gaussian noise
depends on the distance to the neighboring order statistics of an observation.

The default value of 4.0 preserves the relative ordering of observations in a column, with high probability. As the
value decreases, observations are more and more likely to switch position in the order-statistics.}

\item{randomSeed}{Set to a large integer value to reproduce scamp runs when numberOfThreads==1.
Default value of 0 leads to non-reproducible SCAMP runs regardless of numberOfThreads value.}

\item{allowRepeatedSplitting}{Set to FALSE by default. If TRUE, indicates the search for candidate clusters can
induce modal clusters along the same column vector of dataSet multiple times throughout the search. No matter
the value of this parameter (TRUE OR FALSE), the search for candidate clusters is never allowed to induce modal clusters
along the same column vector twice in a row: from the point of view of SCAMP, this can only arise due to technical
error.}
}
\value{
scamp returns an R list with two entries. Each entry is a vector of strings.
The first entry, named RunOffVote, is a clustering of the dataSet according to a run off vote across the scamp iterations.
The second entry, named MaxVote, is a clustering of the dataSet according to the maximum vote across the scamp iterations.
}
\description{
This function clusters a dataSet using scamp, selective clustering
annotated using modes of projections.
}
\examples{
clusterMatrix <- as.matrix(iris[,-5])
scampClustering <- scamp(dataSet=clusterMatrix,
                         numberIterations=20,
                         maximumClusterNum=20,
                         numberOfThreads=0) #0 automatically sets to
                                                         #hardware max.
table(scampClustering$RunOffVote)
table(scampClustering$MaxVote)
}
