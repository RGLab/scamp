---
title: "Using the N-Dip Facilities"
author: 
- Evan Greene
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: nDip.bib
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
```{r setup, include = FALSE}
knitr::opts_chunk$set(
  comment = "#>",
  fig.width = 6,
  fig.height = 12,
  dpi = 100,
  fig.align = "center"
)
```

# N-Dip Overview

The **scamp** package exports several aspects of the search for candidate clusters to **R** from the underlying
C++ implementation. The goal of this vignette is to show how to use the $N$-dip implementation in **R**.

The function **<span style="color:skyblue">singleDip</span>** returns the p-value of the dip test
of Hartigan and Hartigan @hartigan1985dip. The algorithm for computing the dip test is descrbed in
@hartigan1985algorithm. All N-dip facilities in the **scamp** package are built on top of the implmentation
in the **R** package **diptest** @maechler2009diptest.

The function **<span style="color:skyblue">doubleDip</span>** returns the p-value of the 2-dip
when applied to a sorted data vector with no ties. This function only supports data vectors of
length $500$.

The function **<span style="color:skyblue">tripleDip</span>** returns the p-value of the 3-dip,
when applied to a sorted data vector with no ties. This function only supports data vectors of
length $400$.

The function **<span style="color:skyblue">addNoiseToDataVector</span>** implements 
the structured noise routine (phase 1) of the SCAPM algorithm. This is used to break ties 
and perturb relative order in the search for candidate clusters.

The 2-dip, 3-dip, and structured noise phase are described in detail in
[Selective Clustering Annotated using Modes of Projections](https://arxiv.org).

# Examples: the dip test and structured noise

To begin, we sample some Gaussian data and apply the dip test.

```{r first-example, warining=FALSE, eval=TRUE}
library(scamp)
set.seed(12345)
dataVector <- rnorm(200)
dipPval <- round(singleDip(sort(dataVector)),2)
hist(dataVector, breaks="FD",main=paste0("Dip test p value: ",dipPval))
```

Based on the p-value `r dipPval`, we would fail to reject the hypothsis of unimodality at level $\alpha = 0.25$.
The search for candidate clusters would terminate.

Next we sample data with ties. 

```{r second-example, warining=FALSE, eval=TRUE}
set.seed(12345)
dataVector <- rpois(200,lambda=5)
dipPval <- round(singleDip(sort(dataVector)),2)
par(mfrow=c(1,2))
hist(dataVector, breaks="FD",main=paste0("Dip test p value: ",dipPval))
plot(ecdf(dataVector))
```

The multiple jumps visible in the ecdf lead the dip test to 
Based on the p-value `r dipPval`, we would incorrectly
reject the hypothsis of unimodality at level $\alpha = 0.25$.
The search for candidate clusters continue. 

To deal with such a situation we apply **<span style="color:skyblue">addNoiseToDataVector</span>**.
This function takes three arguments: the dataVector as the first parameter, $\gamma$ as the second parameter,
and a random seed value as the third parameter. We use the default value $\gamma=4$ to break the ties.

```{r third-example, warining=FALSE, eval=TRUE}
noisyDataVector <- addNoiseToDataVector(dataVector,4,56789)
dipPval <- round(singleDip(sort(noisyDataVector)),2)
par(mfrow=c(1,2))
hist(noisyDataVector, breaks="FD",main=paste0("Dip test p value: ",dipPval))
plot(ecdf(noisyDataVector))
```

Based on the p-value `r dipPval`, we now
reject the hypothsis of unimodality at level $\alpha = 0.25$.
The search for candidate clusters would terminate, as desired. 

# Example: the $2$-dip 

The **<span style="color:skyblue">doubleDip</span>** and **<span style="color:skyblue">tripleDip</span>**
interfaces are the same as the **<span style="color:skyblue">singleDip</span>**: they all 
should be applied to sorted numeric data vectors without ties, and all return the p-value.

To begin, we sample a mixture of two Gaussians.

```{r fourth-example, warining=FALSE, eval=TRUE}
set.seed(874)
dataVector <- c(rnorm(200),rnorm(200,mean=5,sd=2))
dipPval <- round(singleDip(sort(dataVector)),2)
hist(dataVector, breaks="FD",main=paste0("Dip test p value: ",dipPval))
```

At level $\alpha=0.25$ would reject the hypothesis of unimodality in the search for candidate clusters
and call the  **<span style="color:skyblue">doubleDip</span>**.

```{r fifth-example, warining=FALSE, eval=TRUE}
twoDipPval <- round(doubleDip(sort(dataVector)),2)
hist(dataVector, breaks="FD",main=paste0("2-dip p value: ",twoDipPval))
```

At level $\alpha=0.25/2$, we would fail reject the hypothesis of bimodality in the search for candidate clusters.
Consequently, two modal groups would be induced, and the search would continue conditionally along remaining
coordinates.

# Example: the $3$-dip 

The previous facilities can be combined to break ties and conduct mode tests.
To demonstrate this, we simulate from a mixture of gamma, gaussian, and t data.

```{r sixth-example, warning=FALSE, eval=TRUE}
set.seed(12345)
dataVector <- c(rgamma(100,shape=2,rate=1),
                rnorm(100,mean=6,sd=sqrt(0.5)),
                rt(100,df=4,ncp=12))
noisyDataVector <- addNoiseToDataVector(dataVector,4,56789)
dipPval <- round(singleDip(sort(noisyDataVector)),2)
twoDipPval <- round(doubleDip(sort(noisyDataVector)),2)
threeDipPval <- round(tripleDip(sort(noisyDataVector)),2)
hist(dataVector, breaks="FD",main=paste0("Dip test p value: ",dipPval,
                                         "\n2-dip p value: ",twoDipPval,
                                        "\n3-dip p value: ",threeDipPval))

```

Conducted in sequence with $\alpha$ set to $0.25$, 
the search for candidate clusters would reject unimodality on the basis of 
the p value `r dipPval`, reject bimodality on the basis of `r twoDipPval`, and 
fail to reject trimodality on the basis of `r threeDipPval`. Three modal groups would be induced,
and the search would continue conditionally on each sub-group.

#References